// Cookie helper functions
// function setCookie(name, value, days = 365) {
//   const date = new Date();
//   date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
//   const expires = "expires=" + date.toUTCString();
//   document.cookie = `${name}=${value};${expires};path=/`;
// }

// function getCookie(name) {
//   const cookies = document.cookie.split(';');
//   for (let cookie of cookies) {
//     const [cookieName, cookieValue] = cookie.trim().split('=');
//     if (cookieName === name) return cookieValue;
//   }
//   return null;
// }

function setItem(key, value) {
  localStorage.setItem(key, value);
}

function getItem(key) {
  return localStorage.getItem(key);
}


async function AutoGenerateDevice() {
  function generateDeviceId() {
    return 'device-' + Math.random().toString(36).substr(2, 9);
  }

  function getDeviceName() {
    let deviceName = getItem('deviceName');

    if (!deviceName) {
      // Extract device type from userAgent
      const userAgent = navigator.userAgent.toLowerCase();
      if (userAgent.includes("iphone")) {
        deviceName = "iPhone";
      } else if (userAgent.includes("ipad")) {
        deviceName = "iPad";
      } else if (userAgent.includes("android")) {
        deviceName = "Android Device";
      } else if (userAgent.includes("windows")) {
        deviceName = "Windows PC";
      } else if (userAgent.includes("mac")) {
        deviceName = "MacBook";
      } else {
        deviceName = "Unknown Device";
      }

      setItem('deviceName', deviceName);
    }

    return deviceName;
  }

  function generateUsername() {
    let username = getItem('username');

    if (!username) {
      username = "User" + Math.floor(Math.random() * 10000); // Generate random username
      setItem('username', username);
    }

    return username;
  }

  let deviceId = getItem('deviceId');
  if (!deviceId) {
    deviceId = generateDeviceId();
    setItem('deviceId', deviceId);
  }


  let username = generateUsername();
  let deviceName = getDeviceName();

  let autoGeneratedName = `${username} `;

  // Prepare data for API
  const deviceData = {
    deviceId: deviceId,
    deviceName: deviceName,
    UserNameAgent: autoGeneratedName
  };

  try {
    const response = await fetch('https://mystaticdevserver2.share.zrok.io/api/v1/device', {
      method: 'POST',
      headers: {
        'accept': '*/*',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(deviceData)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error registering device:', error);
    throw error;
  }
}

// Rest of your code remains the same (Viewer, activeUser event listeners, etc.)
async function Viewer() {
  try {
    const viewer = document.getElementById("viewer");
    // let viewUser = getCookie('viwer');
    // if(viewUser){
    //   viewer.innerText = `${viewUser}`
    //   return viewUser;
    // }
    const response = await fetch('https://mystaticdevserver2.share.zrok.io/api/v1/device/viewer', {
      method: 'POST',
      headers: {
        'accept': '*/*',
      },
      body: ''
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    let dataRes = {
      code: 200,
      data: data.data.encrypt
    }
    // console.log(dataRes);
    
    let dycryptView = await fetch('https://mystaticdevserver2.share.zrok.io/api/v1/decode', {
      method: 'POST',
      headers: {
        'accept': '*/*',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(dataRes)
    });
    if (!dycryptView.ok) {
      throw new Error(`HTTP error! status: ${dycryptView.status}`);
    }
    let decript = await dycryptView.json()
    // console.log(decript);
    
    const targetValue = parseInt(decript.data.data);
    const currentValue = parseInt(viewer.innerText);
    // setCookie('viwer', data.data);
    // viewer.innerText = `${data.data}`
    animateCount(viewer, currentValue, targetValue, 2000); // animate in 1 second
    return data;
  } catch (error) {
    console.error('Error registering device:', error);
    throw error;
  }
}
function animateCount(element, start, end, duration) {
  const range = end - start;
  const stepTime = Math.abs(Math.floor(duration / range));
  let current = start;
  const increment = end > start ? 1 : -1;

  const timer = setInterval(() => {
    current += increment;
    element.innerText = current;
    if (current === end) {
      clearInterval(timer);
    }
  }, stepTime);
}

Viewer()
AutoGenerateDevice();

const activeUser = document.getElementById("activeUser");

function startMove(e) {
  e.preventDefault();
  let isTouch = e.type.includes("touch");
  let startX = isTouch ? e.touches[0].clientX : e.clientX;
  let startY = isTouch ? e.touches[0].clientY : e.clientY;
  let offsetX = startX - activeUser.getBoundingClientRect().left;
  let offsetY = startY - activeUser.getBoundingClientRect().top;

  function moveElement(e) {
    let clientX = isTouch ? e.touches[0].clientX : e.clientX;
    let clientY = isTouch ? e.touches[0].clientY : e.clientY;
    activeUser.style.left = clientX - offsetX + "px";
    activeUser.style.top = clientY - offsetY + "px";
  }

  function stopMoving() {
    document.removeEventListener("mousemove", moveElement);
    document.removeEventListener("mouseup", stopMoving);
    document.removeEventListener("touchmove", moveElement);
    document.removeEventListener("touchend", stopMoving);
  }

  document.addEventListener(isTouch ? "touchmove" : "mousemove", moveElement);
  document.addEventListener(isTouch ? "touchend" : "mouseup", stopMoving);
}
activeUser.addEventListener("mousedown", startMove);
activeUser.addEventListener("touchstart", startMove);

activeUser.addEventListener("dblclick", () => {
  activeUser.classList.toggle("hidden");
});

// Double-tap detection (for mobile)
let lastTap = 0;
activeUser.addEventListener("touchend", (e) => {
  let currentTime = new Date().getTime();
  let tapLength = currentTime - lastTap;
  if (tapLength < 300 && tapLength > 0) {
    activeUser.classList.toggle("hidden");
  }
  lastTap = currentTime;
});

// Click to show message box
activeUser.addEventListener("click", () => {
  messageBox.classList.add("show");

  // Auto-hide after 3 seconds
  setTimeout(() => {
    messageBox.classList.remove("show");
  }, 3000);
});

// Click to show message box
activeUser.addEventListener("touchend", () => {
  messageBox.classList.add("show");

  // Auto-hide after 3 seconds
  setTimeout(() => {
    messageBox.classList.remove("show");
  }, 3000);
});